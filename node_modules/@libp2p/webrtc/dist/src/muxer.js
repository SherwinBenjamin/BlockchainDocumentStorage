import { logger } from '@libp2p/logger';
import { createStream } from './stream.js';
import { drainAndClose, nopSink, nopSource } from './util.js';
const log = logger('libp2p:webrtc:muxer');
const PROTOCOL = '/webrtc';
export class DataChannelMuxerFactory {
    protocol;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    streamBuffer = [];
    metrics;
    dataChannelOptions;
    constructor(init) {
        this.peerConnection = init.peerConnection;
        this.metrics = init.metrics;
        this.protocol = init.protocol ?? PROTOCOL;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        // store any datachannels opened before upgrade has been completed
        this.peerConnection.ondatachannel = ({ channel }) => {
            const stream = createStream({
                channel,
                direction: 'inbound',
                onEnd: () => {
                    this.streamBuffer = this.streamBuffer.filter(s => s.id !== stream.id);
                },
                ...this.dataChannelOptions
            });
            this.streamBuffer.push(stream);
        };
    }
    createStreamMuxer(init) {
        return new DataChannelMuxer({
            ...init,
            peerConnection: this.peerConnection,
            dataChannelOptions: this.dataChannelOptions,
            metrics: this.metrics,
            streams: this.streamBuffer,
            protocol: this.protocol
        });
    }
}
/**
 * A libp2p data channel stream muxer
 */
export class DataChannelMuxer {
    init;
    /**
     * Array of streams in the data channel
     */
    streams;
    protocol;
    peerConnection;
    dataChannelOptions;
    metrics;
    constructor(init) {
        this.init = init;
        this.streams = init.streams;
        this.peerConnection = init.peerConnection;
        this.protocol = init.protocol ?? PROTOCOL;
        this.metrics = init.metrics;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        /**
         * Fired when a data channel has been added to the connection has been
         * added by the remote peer.
         *
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event}
         */
        this.peerConnection.ondatachannel = ({ channel }) => {
            const stream = createStream({
                channel,
                direction: 'inbound',
                onEnd: () => {
                    log.trace('stream %s %s %s onEnd', stream.direction, stream.id, stream.protocol);
                    drainAndClose(channel, `inbound ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout);
                    this.streams = this.streams.filter(s => s.id !== stream.id);
                    this.metrics?.increment({ stream_end: true });
                    init?.onStreamEnd?.(stream);
                },
                ...this.dataChannelOptions
            });
            this.streams.push(stream);
            this.metrics?.increment({ incoming_stream: true });
            init?.onIncomingStream?.(stream);
        };
        const onIncomingStream = init?.onIncomingStream;
        if (onIncomingStream != null) {
            this.streams.forEach(s => { onIncomingStream(s); });
        }
    }
    /**
     * Gracefully close all tracked streams and stop the muxer
     */
    async close(options) {
        try {
            await Promise.all(this.streams.map(async (stream) => stream.close(options)));
        }
        catch (err) {
            this.abort(err);
        }
    }
    /**
     * Abort all tracked streams and stop the muxer
     */
    abort(err) {
        for (const stream of this.streams) {
            stream.abort(err);
        }
    }
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source = nopSource();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink = nopSink;
    newStream() {
        // The spec says the label SHOULD be an empty string: https://github.com/libp2p/specs/blob/master/webrtc/README.md#rtcdatachannel-label
        const channel = this.peerConnection.createDataChannel('');
        const stream = createStream({
            channel,
            direction: 'outbound',
            onEnd: () => {
                log.trace('stream %s %s %s onEnd', stream.direction, stream.id, stream.protocol);
                drainAndClose(channel, `outbound ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout);
                this.streams = this.streams.filter(s => s.id !== stream.id);
                this.metrics?.increment({ stream_end: true });
                this.init?.onStreamEnd?.(stream);
            },
            ...this.dataChannelOptions
        });
        this.streams.push(stream);
        this.metrics?.increment({ outgoing_stream: true });
        return stream;
    }
}
//# sourceMappingURL=muxer.js.map